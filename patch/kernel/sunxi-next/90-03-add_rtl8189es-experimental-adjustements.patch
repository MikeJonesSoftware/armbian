diff --git a/drivers/net/wireless/rtl8189es/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rtl8189es/os_dep/linux/ioctl_cfg80211.c
index ae3ea89..f16ad19
--- a/drivers/net/wireless/rtl8189es/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rtl8189es/os_dep/linux/ioctl_cfg80211.c
@@ -694,7 +694,7 @@ void rtw_cfg80211_ibss_indicate_connect(_adapter *padapter)
 		else
 		{
 			if(scanned == NULL)
-				rtw_warn_on(1);
+				return;
 
 			if (_rtw_memcmp(&(scanned->network.Ssid), &(pnetwork->Ssid), sizeof(NDIS_802_11_SSID)) == _TRUE
 				&& _rtw_memcmp(scanned->network.MacAddress, pnetwork->MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS)) == _TRUE
@@ -796,11 +796,30 @@ void rtw_cfg80211_indicate_connect(_adapter *padapter)
 		u32 freq;
 		u16 channel = cur_network->network.Configuration.DSConfig;
 
+		#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+			struct cfg80211_roam_info roam_info ={};
+		#endif
+		
 		freq = rtw_ch2freq(channel);
 		notify_channel = ieee80211_get_channel(wiphy, freq);
 		#endif
 
 		DBG_871X(FUNC_ADPT_FMT" call cfg80211_roamed\n", FUNC_ADPT_ARG(padapter));
+		
+		#if LINUX_VERSION_CODE>=KERNEL_VERSION(4,12,0)
+ 				roam_info.channel = notify_channel;
+ 				roam_info.bssid = cur_network->network.MacAddress;
+ 				roam_info.req_ie =
+ 					pmlmepriv->assoc_req+sizeof(struct rtw_ieee80211_hdr_3addr) + 2;
+ 				roam_info.req_ie_len =
+ 					pmlmepriv->assoc_req_len+sizeof(struct rtw_ieee80211_hdr_3addr) - 2;
+ 				roam_info.resp_ie =
+ 					pmlmepriv->assoc_rsp+sizeof(struct rtw_ieee80211_hdr_3addr) + 6;
+ 				roam_info.resp_ie_len =
+ 					pmlmepriv->assoc_rsp_len+sizeof(struct rtw_ieee80211_hdr_3addr) - 6;
+ 				cfg80211_roamed(padapter->pnetdev, &roam_info, GFP_ATOMIC);
+ 		#else
+		
 		cfg80211_roamed(padapter->pnetdev
 			#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39) || defined(COMPAT_KERNEL_RELEASE)
 			, notify_channel
@@ -811,6 +830,7 @@ void rtw_cfg80211_indicate_connect(_adapter *padapter)
 			, pmlmepriv->assoc_rsp+sizeof(struct rtw_ieee80211_hdr_3addr)+6
 			, pmlmepriv->assoc_rsp_len-sizeof(struct rtw_ieee80211_hdr_3addr)-6
 			, GFP_ATOMIC);
+		#endif	
 	}
 	else
 	{
@@ -1230,7 +1250,7 @@ _func_enter_;
 	{
 		if (param->u.crypt.idx >= WEP_KEYS
 #ifdef CONFIG_IEEE80211W
-			&& param->u.crypt.idx > BIP_MAX_KEYID
+			|| param->u.crypt.idx >= BIP_MAX_KEYID
 #endif //CONFIG_IEEE80211W
 		)
 		{
@@ -1255,7 +1275,7 @@ _func_enter_;
 		wep_key_idx = param->u.crypt.idx;
 		wep_key_len = param->u.crypt.key_len;
 
-		if ((wep_key_idx > WEP_KEYS) || (wep_key_len <= 0))
+		if ((wep_key_idx >= WEP_KEYS) || (wep_key_len <= 0))
 		{
 			ret = -EINVAL;
 			goto exit;
@@ -1868,7 +1888,10 @@ enum nl80211_iftype {
 */
 static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 				     struct net_device *ndev,
-				     enum nl80211_iftype type, u32 *flags,
+				     enum nl80211_iftype type,
+						#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
+						u32 *flags,
+						#endif
 				     struct vif_params *params)
 {
 	enum nl80211_iftype old_type;
@@ -3709,8 +3732,10 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 	
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	if (skb)
-		rtw_mstat_update(MSTAT_TYPE_SKB, MSTAT_ALLOC_SUCCESS, skb->truesize);
+	if (!skb)
+ 		goto fail;
+ 
+	rtw_mstat_update(MSTAT_TYPE_SKB, MSTAT_ALLOC_SUCCESS, skb->truesize);
 
 	if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))
 		goto fail;
@@ -3913,7 +3938,12 @@ static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct ne
 	mon_ndev->type = ARPHRD_IEEE80211_RADIOTAP;
 	strncpy(mon_ndev->name, name, IFNAMSIZ);
 	mon_ndev->name[IFNAMSIZ - 1] = 0;
-	mon_ndev->destructor = rtw_ndev_destructor;
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,11,9))
+ 	mon_ndev->needs_free_netdev = false;
+ 	mon_ndev->priv_destructor = rtw_ndev_destructor;
+	#else
+		mon_ndev->destructor = rtw_ndev_destructor;
+	#endif
 	
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 	mon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;
@@ -3980,7 +4010,11 @@ static int
 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0))
 		unsigned char name_assign_type,
 	#endif
-		enum nl80211_iftype type, u32 *flags, struct vif_params *params)
+		enum nl80211_iftype type, 
+ 		#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
+ 		u32 *flags,
+ 		#endif
+ 		struct vif_params *params)
 {
 	int ret = 0;
 	struct net_device* ndev = NULL;
@@ -6374,7 +6408,11 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *adapter, struct wiphy *wiphy)
 #endif
 
 #if defined(CONFIG_PM) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
-	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+  	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#else //kernel >=4.12
+	wiphy->max_sched_scan_reqs = 1;
+#endif
 #ifdef CONFIG_PNO_SUPPORT
 	wiphy->max_sched_scan_ssids = MAX_PNO_LIST_COUNT;
 #endif

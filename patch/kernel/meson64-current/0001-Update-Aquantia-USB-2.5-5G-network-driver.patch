From a80bffcf25563673bf642c8c16d316dcb69464a3 Mon Sep 17 00:00:00 2001
From: Igor Pecovnik <igor.pecovnik@gmail.com>
Date: Sun, 6 Sep 2020 15:47:16 +0200
Subject: [PATCH] Update Aquantia USB 2.5/5G network driver

Signed-off-by: Igor Pecovnik <igor.pecovnik@gmail.com>
---
 drivers/net/usb/aq_compat.h |  86 ++++++
 drivers/net/usb/aqc111.c    | 567 +++++++++++++++++++++++++++++-------
 drivers/net/usb/aqc111.h    |  80 ++++-
 3 files changed, 625 insertions(+), 108 deletions(-)
 create mode 100644 drivers/net/usb/aq_compat.h

diff --git a/drivers/net/usb/aq_compat.h b/drivers/net/usb/aq_compat.h
new file mode 100644
index 000000000..612ab48f0
--- /dev/null
+++ b/drivers/net/usb/aq_compat.h
@@ -0,0 +1,86 @@
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+#include <linux/usb/usbnet.h>
+#else
+#include <../drivers/usb/net/usbnet.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+#include <linux/linkmode.h>
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 10)
+typedef u32 pm_message_t;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
+#define usbnet_get_stats64 NULL
+#endif
+
+#ifndef RHEL_RELEASE_VERSION
+#define RHEL_RELEASE_VERSION(a,b) (((a) << 8) + (b))
+#endif
+
+#ifndef RHEL_RELEASE_CODE
+#define RHEL_RELEASE_CODE 0
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+int usbnet_read_cmd(struct usbnet *dev, u8 cmd, u8 reqtype, u16 value, u16 index,
+		    void *data, u16 size)
+{
+	return usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
+			       cmd, reqtype, value, index, data, size,
+			       USB_CTRL_GET_TIMEOUT);
+}
+
+int usbnet_read_cmd_nopm(struct usbnet *dev, u8 cmd, u8 reqtype, u16 value,
+			 u16 index, void *data, u16 size)
+{
+	 return usbnet_read_cmd(dev, cmd, reqtype, value,
+				index, data, size);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+#define SPEED_5000 5000
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0)
+#define usbnet_set_skb_tx_stats(skb, packets, bytes_delta)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0) && !(RHEL_RELEASE_CODE)
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0) && \
+    LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+static inline void linkmode_copy(unsigned long *dst, const unsigned long *src)
+{
+	bitmap_copy(dst, src, __ETHTOOL_LINK_MODE_MASK_NBITS);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0)
+#if !(RHEL_RELEASE_CODE) || RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,5)
+static inline void *skb_put_data(struct sk_buff *skb, const void *data,
+				 unsigned int len)
+{
+	void *tmp = skb_put(skb, len);
+
+	memcpy(tmp, data, len);
+
+	return tmp;
+}
+#endif
+#endif
diff --git a/drivers/net/usb/aqc111.c b/drivers/net/usb/aqc111.c
index 7e4411074..2da52acfe 100644
--- a/drivers/net/usb/aqc111.c
+++ b/drivers/net/usb/aqc111.c
@@ -7,6 +7,7 @@
  * Copyright (C) 2018 Aquantia Corp.
  */
 
+#include <linux/version.h>
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
@@ -15,11 +16,12 @@
 #include <linux/crc32.h>
 #include <linux/if_vlan.h>
 #include <linux/usb/cdc.h>
-#include <linux/usb/usbnet.h>
-#include <linux/linkmode.h>
+#include <linux/workqueue.h>
 
+#include "aq_compat.h"
 #include "aqc111.h"
 
+#define DRIVER_VERSION "1.3.3.0"
 #define DRIVER_NAME "aqc111"
 
 static int aqc111_read_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
@@ -193,6 +195,71 @@ static int aqc111_write16_cmd_async(struct usbnet *dev, u8 cmd, u16 value,
 				      sizeof(tmp), &tmp);
 }
 
+static int aqc111_mdio_read(struct usbnet *dev, u16 value, u16 index, u16 *data)
+{
+	return aqc111_read16_cmd(dev, AQ_PHY_CMD, value, index, data);
+}
+
+static int aqc111_mdio_write(struct usbnet *dev, u16 value,
+			     u16 index, u16 *data)
+{
+	return aqc111_write16_cmd(dev, AQ_PHY_CMD, value, index, data);
+}
+
+#if KERNEL_VERSION(4, 6, 0) > LINUX_VERSION_CODE
+static int aqc111_get_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct aqc111_data *aqc111_data = dev->driver_priv;
+	struct mii_if_info *mii = &dev->mii;
+	u32 speed = SPEED_UNKNOWN;
+
+	cmd->supported =
+		(SUPPORTED_100baseT_Full |
+		 SUPPORTED_1000baseT_Full |
+		 SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII);
+
+	/* only supports twisted-pair */
+	cmd->port = PORT_MII;
+
+	/* only supports internal transceiver */
+	cmd->transceiver = XCVR_INTERNAL;
+
+	/* this isn't fully supported at higher layers */
+	cmd->phy_address = mii->phy_id;
+	cmd->mdio_support = 0x00; /*Not supported*/
+
+	cmd->advertising =
+		(ADVERTISED_100baseT_Full |
+		 ADVERTISED_1000baseT_Full |
+		 ADVERTISED_Autoneg | ADVERTISED_TP | ADVERTISED_MII);
+
+	cmd->autoneg = aqc111_data->autoneg;
+
+	switch (aqc111_data->link_speed) {
+	case AQ_INT_SPEED_5G:
+		speed = SPEED_5000;
+		break;
+	case AQ_INT_SPEED_2_5G:
+		speed = SPEED_2500;
+		break;
+	case AQ_INT_SPEED_1G:
+		speed = SPEED_1000;
+		break;
+	case AQ_INT_SPEED_100M:
+		speed = SPEED_100;
+		break;
+	}
+	cmd->duplex = DUPLEX_FULL;
+
+	ethtool_cmd_speed_set(cmd, speed);
+
+	mii->full_duplex = cmd->duplex;
+
+	return 0;
+}
+#endif
+
 static void aqc111_get_drvinfo(struct net_device *net,
 			       struct ethtool_drvinfo *info)
 {
@@ -202,6 +269,7 @@ static void aqc111_get_drvinfo(struct net_device *net,
 	/* Inherit standard device info */
 	usbnet_get_drvinfo(net, info);
 	strlcpy(info->driver, DRIVER_NAME, sizeof(info->driver));
+	strlcpy(info->version, DRIVER_VERSION, sizeof(info->version));
 	snprintf(info->fw_version, sizeof(info->fw_version), "%u.%u.%u",
 		 aqc111_data->fw_ver.major,
 		 aqc111_data->fw_ver.minor,
@@ -239,10 +307,221 @@ static int aqc111_set_wol(struct net_device *net,
 	return 0;
 }
 
+static const char aqc111_priv_flag_names[][ETH_GSTRING_LEN] = {
+	"Low Power 5G",
+	"Thermal throttling",
+};
+
+static void aqc111_get_strings(struct net_device *net, u32 stringset, u8 *data)
+{
+	switch (stringset) {
+	case  ETH_SS_PRIV_FLAGS:
+		memcpy(data, aqc111_priv_flag_names,
+		       sizeof(aqc111_priv_flag_names));
+		break;
+	}
+}
+
+static u32 aqc111_get_priv_flags(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct aqc111_data *aqc111_data = dev->driver_priv;
+
+	return aqc111_data->priv_flags;
+}
+
+static void aqc111_set_phy_speed_fw_iface(struct usbnet *dev,
+					  struct aqc111_data *aqc111_data)
+{
+	aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0, &aqc111_data->phy_cfg);
+}
+
+static void aqc111_set_phy_speed_direct(struct usbnet *dev,
+					struct aqc111_data *aqc111_data)
+{
+	u16 reg16_1 = 0;
+	u16 reg16_2 = 0;
+	u16 reg16_3 = 0;
+
+	/* Disable auto-negotiation */
+	reg16_1 = AQ_ANEG_EX_PAGE_CTRL;
+	aqc111_mdio_write(dev, AQ_AUTONEG_STD_CTRL_REG, AQ_PHY_AUTONEG_ADDR,
+			  &reg16_1);
+
+	reg16_1 = AQ_ANEG_EX_PHY_ID | AQ_ANEG_ADV_AQRATE;
+	if (aqc111_data->phy_cfg & AQ_DOWNSHIFT) {
+		reg16_1 |= AQ_ANEG_EN_DSH;
+		reg16_1 |= (aqc111_data->phy_cfg & AQ_DSH_RETRIES_MASK) >>
+			    AQ_DSH_RETRIES_SHIFT;
+	}
+
+	reg16_2 = AQ_ANEG_ADV_LT;
+	if (aqc111_data->phy_cfg & AQ_PAUSE)
+		reg16_3 |= AQ_ANEG_PAUSE;
+
+	if (aqc111_data->phy_cfg & AQ_ASYM_PAUSE)
+		reg16_3 |= AQ_ANEG_ASYM_PAUSE;
+
+	if (aqc111_data->phy_cfg & AQ_ADV_5G) {
+		reg16_1 |= AQ_ANEG_ADV_5G_N;
+		reg16_2 |= AQ_ANEG_ADV_5G_T;
+	}
+	if (aqc111_data->phy_cfg & AQ_ADV_2G5) {
+		reg16_1 |= AQ_ANEG_ADV_2G5_N;
+		reg16_2 |= AQ_ANEG_ADV_2G5_T;
+	}
+	if (aqc111_data->phy_cfg & AQ_ADV_1G)
+		reg16_1 |= AQ_ANEG_ADV_1G;
+
+	if (aqc111_data->phy_cfg & AQ_ADV_100M)
+		reg16_3 |= AQ_ANEG_100M;
+
+	aqc111_mdio_write(dev, AQ_AUTONEG_VEN_PROV1_REG,
+			  AQ_PHY_AUTONEG_ADDR, &reg16_1);
+	aqc111_mdio_write(dev, AQ_AUTONEG_10GT_CTRL_REG,
+			  AQ_PHY_AUTONEG_ADDR, &reg16_2);
+
+	aqc111_mdio_read(dev, AQ_GLB_SYS_CFG_REG_5G, AQ_PHY_GLOBAL_ADDR,
+			 &reg16_1);
+	reg16_1 &= ~AQ_SERDES_MODE_MASK;
+	if (aqc111_data->phy_cfg & AQ_XFI_DIV_2)
+		reg16_1 |= AQ_SERDES_MODE_XFI_DIV_2;
+	else
+		reg16_1 |= AQ_SERDES_MODE_XFI;
+
+	aqc111_mdio_write(dev, AQ_GLB_SYS_CFG_REG_5G, AQ_PHY_GLOBAL_ADDR,
+			  &reg16_1);
+
+	aqc111_mdio_read(dev, AQ_AUTONEG_ADV_REG, AQ_PHY_AUTONEG_ADDR,
+			 &reg16_1);
+	reg16_1 &= ~AQ_ANEG_ABILITY_MASK;
+	reg16_1 |= reg16_3;
+	aqc111_mdio_write(dev, AQ_AUTONEG_ADV_REG, AQ_PHY_AUTONEG_ADDR,
+			  &reg16_1);
+
+	/* Restart auto-negotiation */
+	reg16_1 = AQ_ANEG_EX_PAGE_CTRL | AQ_ANEG_EN_ANEG |
+		  AQ_ANEG_RESTART_ANEG;
+
+	aqc111_mdio_write(dev, AQ_AUTONEG_STD_CTRL_REG,
+			  AQ_PHY_AUTONEG_ADDR, &reg16_1);
+}
+
+static void aqc111_set_phy_speed(struct usbnet *dev, u8 autoneg, u16 speed)
+{
+	struct aqc111_data *aqc111_data = dev->driver_priv;
+
+	aqc111_data->phy_cfg &= ~AQ_ADV_MASK;
+	aqc111_data->phy_cfg |= AQ_PAUSE;
+	aqc111_data->phy_cfg |= AQ_ASYM_PAUSE;
+	aqc111_data->phy_cfg |= AQ_DOWNSHIFT;
+	aqc111_data->phy_cfg &= ~AQ_DSH_RETRIES_MASK;
+	aqc111_data->phy_cfg |= (3 << AQ_DSH_RETRIES_SHIFT) &
+				AQ_DSH_RETRIES_MASK;
+
+	aqc111_data->phy_cfg &= ~AQ_XFI_DIV_2;
+	if (aqc111_data->priv_flags & AQ_PF_XFI_DIV_2)
+		aqc111_data->phy_cfg |= AQ_XFI_DIV_2;
+
+	if (autoneg == AUTONEG_ENABLE) {
+		switch (speed) {
+		case SPEED_5000:
+			aqc111_data->phy_cfg |= AQ_ADV_5G;
+			/* fall-through */
+		case SPEED_2500:
+			aqc111_data->phy_cfg |= AQ_ADV_2G5;
+			/* fall-through */
+		case SPEED_1000:
+			aqc111_data->phy_cfg |= AQ_ADV_1G;
+			/* fall-through */
+		case SPEED_100:
+			aqc111_data->phy_cfg |= AQ_ADV_100M;
+			/* fall-through */
+		}
+	} else {
+		switch (speed) {
+		case SPEED_5000:
+			aqc111_data->phy_cfg |= AQ_ADV_5G;
+			break;
+		case SPEED_2500:
+			aqc111_data->phy_cfg |= AQ_ADV_2G5;
+			break;
+		case SPEED_1000:
+			aqc111_data->phy_cfg |= AQ_ADV_1G;
+			break;
+		case SPEED_100:
+			aqc111_data->phy_cfg |= AQ_ADV_100M;
+			break;
+		}
+	}
+
+	if (aqc111_data->dpa)
+		aqc111_set_phy_speed_direct(dev, aqc111_data);
+	else
+		aqc111_set_phy_speed_fw_iface(dev, aqc111_data);
+}
+
+static int aqc111_update_thermal_params(struct usbnet *dev)
+{
+	struct aqc111_data *aqc111_data = dev->driver_priv;
+	struct aqc111_thermal_params therm_params = {};
+
+	therm_params.enable = (aqc111_data->priv_flags & AQ_PF_THERMAL) ? 1 : 0;
+	therm_params.threshold_critical = AQ_CRITICAL_TEMP_THRESHOLD;
+	therm_params.threshold_high = AQ_HIGH_TEMP_THRESHOLD;
+	therm_params.threshold_normal = AQ_NORMAL_TEMP_THRESHOLD;
+	therm_params.phy_speed_mask = AQ_ADV_100M;
+	return aqc111_write_cmd(dev, AQ_PHY_THERMAL, 0, 0,
+				sizeof(struct aqc111_thermal_params),
+				&therm_params);
+}
+
+static int aqc111_set_priv_flags(struct net_device *net, u32 flags)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct aqc111_data *aqc111_data = dev->driver_priv;
+	u32 changed;
+
+	if (flags & ~AQ_PRIV_FLAGS_MASK)
+		return -EOPNOTSUPP;
+
+	changed = aqc111_data->priv_flags^flags;
+	aqc111_data->priv_flags = flags;
+
+	if (!(aqc111_data->phy_cfg & AQ_LOW_POWER) &&
+	    (aqc111_data->phy_cfg & AQ_PHY_POWER_EN)) {
+		if (changed & AQ_PF_XFI_DIV_2) {
+			aqc111_set_phy_speed(dev, aqc111_data->autoneg,
+					     aqc111_data->advertised_speed);
+		}
+	}
+	if (changed & AQ_PF_THERMAL)
+		aqc111_update_thermal_params(dev);
+
+	return 0;
+}
+
+static int aqc111_get_sset_count(struct net_device *net, int stringset)
+{
+	int ret = 0;
+
+	switch (stringset) {
+	case ETH_SS_PRIV_FLAGS:
+		ret = ARRAY_SIZE(aqc111_priv_flag_names);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+#if KERNEL_VERSION(4, 6, 0) <= LINUX_VERSION_CODE
 static void aqc111_speed_to_link_mode(u32 speed,
 				      struct ethtool_link_ksettings *elk)
 {
 	switch (speed) {
+#if KERNEL_VERSION(4, 10, 0) <= LINUX_VERSION_CODE
 	case SPEED_5000:
 		ethtool_link_ksettings_add_link_mode(elk, advertising,
 						     5000baseT_Full);
@@ -251,6 +530,7 @@ static void aqc111_speed_to_link_mode(u32 speed,
 		ethtool_link_ksettings_add_link_mode(elk, advertising,
 						     2500baseT_Full);
 		break;
+#endif
 	case SPEED_1000:
 		ethtool_link_ksettings_add_link_mode(elk, advertising,
 						     1000baseT_Full);
@@ -275,17 +555,21 @@ static int aqc111_get_link_ksettings(struct net_device *net,
 					     100baseT_Full);
 	ethtool_link_ksettings_add_link_mode(elk, supported,
 					     1000baseT_Full);
+#if KERNEL_VERSION(4, 10, 0) <= LINUX_VERSION_CODE
 	if (usb_speed == USB_SPEED_SUPER) {
 		ethtool_link_ksettings_add_link_mode(elk, supported,
 						     2500baseT_Full);
 		ethtool_link_ksettings_add_link_mode(elk, supported,
 						     5000baseT_Full);
 	}
+#endif
 	ethtool_link_ksettings_add_link_mode(elk, supported, TP);
 	ethtool_link_ksettings_add_link_mode(elk, supported, Autoneg);
 
 	elk->base.port = PORT_TP;
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
 	elk->base.transceiver = XCVR_INTERNAL;
+#endif
 
 	elk->base.mdio_support = 0x00; /*Not supported*/
 
@@ -316,63 +600,27 @@ static int aqc111_get_link_ksettings(struct net_device *net,
 
 	return 0;
 }
+#endif
 
-static void aqc111_set_phy_speed(struct usbnet *dev, u8 autoneg, u16 speed)
-{
-	struct aqc111_data *aqc111_data = dev->driver_priv;
-
-	aqc111_data->phy_cfg &= ~AQ_ADV_MASK;
-	aqc111_data->phy_cfg |= AQ_PAUSE;
-	aqc111_data->phy_cfg |= AQ_ASYM_PAUSE;
-	aqc111_data->phy_cfg |= AQ_DOWNSHIFT;
-	aqc111_data->phy_cfg &= ~AQ_DSH_RETRIES_MASK;
-	aqc111_data->phy_cfg |= (3 << AQ_DSH_RETRIES_SHIFT) &
-				AQ_DSH_RETRIES_MASK;
-
-	if (autoneg == AUTONEG_ENABLE) {
-		switch (speed) {
-		case SPEED_5000:
-			aqc111_data->phy_cfg |= AQ_ADV_5G;
-			/* fall-through */
-		case SPEED_2500:
-			aqc111_data->phy_cfg |= AQ_ADV_2G5;
-			/* fall-through */
-		case SPEED_1000:
-			aqc111_data->phy_cfg |= AQ_ADV_1G;
-			/* fall-through */
-		case SPEED_100:
-			aqc111_data->phy_cfg |= AQ_ADV_100M;
-			/* fall-through */
-		}
-	} else {
-		switch (speed) {
-		case SPEED_5000:
-			aqc111_data->phy_cfg |= AQ_ADV_5G;
-			break;
-		case SPEED_2500:
-			aqc111_data->phy_cfg |= AQ_ADV_2G5;
-			break;
-		case SPEED_1000:
-			aqc111_data->phy_cfg |= AQ_ADV_1G;
-			break;
-		case SPEED_100:
-			aqc111_data->phy_cfg |= AQ_ADV_100M;
-			break;
-		}
-	}
-
-	aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0, &aqc111_data->phy_cfg);
-}
-
+#if KERNEL_VERSION(4, 6, 0) <= LINUX_VERSION_CODE
 static int aqc111_set_link_ksettings(struct net_device *net,
 				     const struct ethtool_link_ksettings *elk)
+#else
+static int aqc111_set_settings(struct net_device *net, struct ethtool_cmd *cmd)
+#endif
 {
 	struct usbnet *dev = netdev_priv(net);
 	struct aqc111_data *aqc111_data = dev->driver_priv;
 	enum usb_device_speed usb_speed = dev->udev->speed;
+#if KERNEL_VERSION(4, 6, 0) <= LINUX_VERSION_CODE
 	u8 autoneg = elk->base.autoneg;
 	u32 speed = elk->base.speed;
-
+	u8 duplex = elk->base.duplex;
+#else
+	u16 speed = ethtool_cmd_speed(cmd);
+	u8 autoneg = cmd->autoneg;
+	u8 duplex = cmd->duplex;
+#endif
 	if (autoneg == AUTONEG_ENABLE) {
 		if (aqc111_data->autoneg != AUTONEG_ENABLE) {
 			aqc111_data->autoneg = AUTONEG_ENABLE;
@@ -390,7 +638,7 @@ static int aqc111_set_link_ksettings(struct net_device *net,
 		    speed != SPEED_UNKNOWN)
 			return -EINVAL;
 
-		if (elk->base.duplex != DUPLEX_FULL)
+		if (duplex != DUPLEX_FULL)
 			return -EINVAL;
 
 		if (usb_speed != USB_SPEED_SUPER && speed > SPEED_1000)
@@ -408,14 +656,24 @@ static int aqc111_set_link_ksettings(struct net_device *net,
 }
 
 static const struct ethtool_ops aqc111_ethtool_ops = {
+#if KERNEL_VERSION(4, 6, 0) > LINUX_VERSION_CODE
+	.get_settings = aqc111_get_settings,
+	.set_settings = aqc111_set_settings,
+#endif
 	.get_drvinfo = aqc111_get_drvinfo,
 	.get_wol = aqc111_get_wol,
 	.set_wol = aqc111_set_wol,
 	.get_msglevel = usbnet_get_msglevel,
 	.set_msglevel = usbnet_set_msglevel,
 	.get_link = ethtool_op_get_link,
+	.get_strings = aqc111_get_strings,
+	.get_priv_flags = aqc111_get_priv_flags,
+	.set_priv_flags = aqc111_set_priv_flags,
+	.get_sset_count = aqc111_get_sset_count,
+#if KERNEL_VERSION(4, 6, 0) <= LINUX_VERSION_CODE
 	.get_link_ksettings = aqc111_get_link_ksettings,
 	.set_link_ksettings = aqc111_set_link_ksettings
+#endif
 };
 
 static int aqc111_change_mtu(struct net_device *net, int new_mtu)
@@ -424,6 +682,11 @@ static int aqc111_change_mtu(struct net_device *net, int new_mtu)
 	u16 reg16 = 0;
 	u8 buf[5];
 
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	if (new_mtu <= 0 || new_mtu > 16334)
+		return -EINVAL;
+#endif
+
 	net->mtu = new_mtu;
 	dev->hard_mtu = net->mtu + net->hard_header_len;
 
@@ -437,7 +700,7 @@ static int aqc111_change_mtu(struct net_device *net, int new_mtu)
 	aqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,
 			   2, &reg16);
 
-	if (dev->net->mtu > 12500) {
+	if (dev->net->mtu > 12500 && dev->net->mtu <= 16334) {
 		memcpy(buf, &AQC111_BULKIN_SIZE[2], 5);
 		/* RX bulk configuration */
 		aqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_RX_BULKIN_QCTRL,
@@ -451,7 +714,7 @@ static int aqc111_change_mtu(struct net_device *net, int new_mtu)
 		reg16 = 0x1020;
 	else if (dev->net->mtu <= 12500)
 		reg16 = 0x1420;
-	else
+	else if (dev->net->mtu <= 16334)
 		reg16 = 0x1A20;
 
 	aqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_PAUSE_WATERLVL_LOW,
@@ -642,7 +905,12 @@ static const struct net_device_ops aqc111_netdev_ops = {
 	.ndo_start_xmit		= usbnet_start_xmit,
 	.ndo_tx_timeout		= usbnet_tx_timeout,
 	.ndo_get_stats64	= usbnet_get_stats64,
+#if (RHEL_RELEASE_VERSION(7, 5) <= RHEL_RELEASE_CODE)
+	.extended.ndo_change_mtu = aqc111_change_mtu,
+	.ndo_size		= sizeof(const struct net_device_ops),
+#else
 	.ndo_change_mtu		= aqc111_change_mtu,
+#endif
 	.ndo_set_mac_address	= aqc111_set_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_vlan_rx_add_vid	= aqc111_vlan_rx_add_vid,
@@ -679,6 +947,8 @@ static void aqc111_read_fw_version(struct usbnet *dev,
 
 	if (aqc111_data->fw_ver.major & 0x80)
 		aqc111_data->fw_ver.major &= ~0x80;
+	else
+		aqc111_data->dpa = 1;
 }
 
 static int aqc111_bind(struct usbnet *dev, struct usb_interface *intf)
@@ -688,6 +958,9 @@ static int aqc111_bind(struct usbnet *dev, struct usb_interface *intf)
 	struct aqc111_data *aqc111_data;
 	int ret;
 
+	/* Force switch to LAN config */
+	aqc111_write_cmd(dev, AQ_SWITCH_CONFIG, AQ_SW_CONFIG_MAGIC_KEY,
+			 AQ_SW_CONFIG_LAN, 0, NULL);
 	/* Check if vendor configuration */
 	if (udev->actconfig->desc.bConfigurationValue != 1) {
 		usb_driver_set_configuration(udev, 1);
@@ -723,24 +996,30 @@ static int aqc111_bind(struct usbnet *dev, struct usb_interface *intf)
 	dev->net->needed_headroom += sizeof(u64);
 	dev->net->needed_tailroom += sizeof(u64);
 
+#if KERNEL_VERSION(4, 10, 0) <= LINUX_VERSION_CODE
 	dev->net->max_mtu = 16334;
+#elif (RHEL_RELEASE_VERSION(7, 5) <= RHEL_RELEASE_CODE)
+	dev->net->extended->max_mtu = 16334;
+#endif
 
 	dev->net->netdev_ops = &aqc111_netdev_ops;
 	dev->net->ethtool_ops = &aqc111_ethtool_ops;
 
+#if KERNEL_VERSION(3, 12, 0) <= LINUX_VERSION_CODE || (RHEL_RELEASE_CODE)
 	if (usb_device_no_sg_constraint(dev->udev))
 		dev->can_dma_sg = 1;
+#endif
 
 	dev->net->hw_features |= AQ_SUPPORT_HW_FEATURE;
 	dev->net->features |= AQ_SUPPORT_FEATURE;
 	dev->net->vlan_features |= AQ_SUPPORT_VLAN_FEATURE;
 
-	netif_set_gso_max_size(dev->net, 65535);
-
 	aqc111_read_fw_version(dev, aqc111_data);
 	aqc111_data->autoneg = AUTONEG_ENABLE;
 	aqc111_data->advertised_speed = (usb_speed == USB_SPEED_SUPER) ?
 					 SPEED_5000 : SPEED_1000;
+	aqc111_data->priv_flags |= AQ_PF_THERMAL;
+	aqc111_data->rx_checksum = 1;
 
 	return 0;
 
@@ -753,6 +1032,7 @@ static void aqc111_unbind(struct usbnet *dev, struct usb_interface *intf)
 {
 	struct aqc111_data *aqc111_data = dev->driver_priv;
 	u16 reg16;
+	u8 reg8;
 
 	/* Force bz */
 	reg16 = SFR_PHYPWR_RSTCTL_BZ;
@@ -763,11 +1043,17 @@ static void aqc111_unbind(struct usbnet *dev, struct usb_interface *intf)
 				2, &reg16);
 
 	/* Power down ethernet PHY */
-	aqc111_data->phy_cfg &= ~AQ_ADV_MASK;
-	aqc111_data->phy_cfg |= AQ_LOW_POWER;
-	aqc111_data->phy_cfg &= ~AQ_PHY_POWER_EN;
-	aqc111_write32_cmd_nopm(dev, AQ_PHY_OPS, 0, 0,
-				&aqc111_data->phy_cfg);
+	if (aqc111_data->dpa) {
+		reg8 = 0x00;
+		aqc111_write_cmd_nopm(dev, AQ_PHY_POWER, 0,
+				      0, 1, &reg8);
+	} else {
+		aqc111_data->phy_cfg &= ~AQ_ADV_MASK;
+		aqc111_data->phy_cfg |= AQ_LOW_POWER;
+		aqc111_data->phy_cfg &= ~AQ_PHY_POWER_EN;
+		aqc111_write32_cmd_nopm(dev, AQ_PHY_OPS, 0, 0,
+					&aqc111_data->phy_cfg);
+	}
 
 	kfree(aqc111_data);
 }
@@ -833,6 +1119,14 @@ static void aqc111_configure_rx(struct usbnet *dev,
 		break;
 	}
 
+	if (aqc111_data->dpa) {
+		/* Set Phy Flow control */
+		aqc111_mdio_write(dev, AQ_GLB_ING_PAUSE_CTRL_REG,
+				  AQ_PHY_AUTONEG_ADDR, &reg16);
+		aqc111_mdio_write(dev, AQ_GLB_EGR_PAUSE_CTRL_REG,
+				  AQ_PHY_AUTONEG_ADDR, &reg16);
+	}
+
 	aqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_INTER_PACKET_GAP_0,
 			 1, 1, &reg8);
 
@@ -989,12 +1283,15 @@ static int aqc111_link_reset(struct usbnet *dev)
 static int aqc111_reset(struct usbnet *dev)
 {
 	struct aqc111_data *aqc111_data = dev->driver_priv;
+	u16 reg16 = 0;
 	u8 reg8 = 0;
 
 	dev->rx_urb_size = URB_SIZE;
 
+#if KERNEL_VERSION(3, 12, 0) <= LINUX_VERSION_CODE || (RHEL_RELEASE_CODE)
 	if (usb_device_no_sg_constraint(dev->udev))
 		dev->can_dma_sg = 1;
+#endif
 
 	dev->net->hw_features |= AQ_SUPPORT_HW_FEATURE;
 	dev->net->features |= AQ_SUPPORT_FEATURE;
@@ -1002,8 +1299,25 @@ static int aqc111_reset(struct usbnet *dev)
 
 	/* Power up ethernet PHY */
 	aqc111_data->phy_cfg = AQ_PHY_POWER_EN;
-	aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,
-			   &aqc111_data->phy_cfg);
+	if (aqc111_data->dpa) {
+		aqc111_read_cmd(dev, AQ_PHY_POWER, 0, 0, 1, &reg8);
+		if (reg8 == 0x00) {
+			reg8 = 0x02;
+			aqc111_write_cmd(dev, AQ_PHY_POWER, 0, 0, 1, &reg8);
+			msleep(200);
+		}
+
+		aqc111_mdio_read(dev, AQ_GLB_STD_CTRL_REG, AQ_PHY_GLOBAL_ADDR,
+				 &reg16);
+		if (reg16 & AQ_PHY_LOW_POWER_MODE) {
+			reg16 &= ~AQ_PHY_LOW_POWER_MODE;
+			aqc111_mdio_write(dev, AQ_GLB_STD_CTRL_REG,
+					  AQ_PHY_GLOBAL_ADDR, &reg16);
+		}
+	} else {
+		aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,
+				   &aqc111_data->phy_cfg);
+	}
 
 	/* Set the MAC address */
 	aqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_NODE_ID, ETH_ALEN,
@@ -1023,6 +1337,8 @@ static int aqc111_reset(struct usbnet *dev)
 
 	netif_carrier_off(dev->net);
 
+	aqc111_update_thermal_params(dev);
+
 	/* Phy advertise */
 	aqc111_set_phy_speed(dev, aqc111_data->autoneg,
 			     aqc111_data->advertised_speed);
@@ -1044,25 +1360,31 @@ static int aqc111_stop(struct usbnet *dev)
 	aqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_RX_CTL, 2, &reg16);
 
 	/* Put PHY to low power*/
-	aqc111_data->phy_cfg |= AQ_LOW_POWER;
-	aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,
-			   &aqc111_data->phy_cfg);
+	if (aqc111_data->dpa) {
+		reg16 = AQ_PHY_LOW_POWER_MODE;
+		aqc111_mdio_write(dev, AQ_GLB_STD_CTRL_REG, AQ_PHY_GLOBAL_ADDR,
+				  &reg16);
+	} else {
+		aqc111_data->phy_cfg |= AQ_LOW_POWER;
+		aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,
+				   &aqc111_data->phy_cfg);
+	}
 
 	netif_carrier_off(dev->net);
 
 	return 0;
 }
 
-static void aqc111_rx_checksum(struct sk_buff *skb, u64 pkt_desc)
+static void aqc111_rx_checksum(struct sk_buff *skb, u64 *pkt_desc)
 {
 	u32 pkt_type = 0;
 
 	skb->ip_summed = CHECKSUM_NONE;
 	/* checksum error bit is set */
-	if (pkt_desc & AQ_RX_PD_L4_ERR || pkt_desc & AQ_RX_PD_L3_ERR)
+	if (*pkt_desc & AQ_RX_PD_L4_ERR || *pkt_desc & AQ_RX_PD_L3_ERR)
 		return;
 
-	pkt_type = pkt_desc & AQ_RX_PD_L4_TYPE_MASK;
+	pkt_type = *pkt_desc & AQ_RX_PD_L4_TYPE_MASK;
 	/* It must be a TCP or UDP packet with a valid checksum */
 	if (pkt_type == AQ_RX_PD_L4_TCP || pkt_type == AQ_RX_PD_L4_UDP)
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
@@ -1073,8 +1395,8 @@ static int aqc111_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 	struct aqc111_data *aqc111_data = dev->driver_priv;
 	struct sk_buff *new_skb = NULL;
 	u32 pkt_total_offset = 0;
-	u64 *pkt_desc_ptr = NULL;
 	u32 start_of_descs = 0;
+	u64 *pkt_desc = NULL;
 	u32 desc_offset = 0; /*RX Header Offset*/
 	u16 pkt_count = 0;
 	u64 desc_hdr = 0;
@@ -1090,7 +1412,8 @@ static int aqc111_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 	skb_len = skb->len;
 	/* RX Descriptor Header */
 	skb_trim(skb, skb->len - sizeof(desc_hdr));
-	desc_hdr = le64_to_cpup((u64 *)skb_tail_pointer(skb));
+	desc_hdr = *(u64 *)skb_tail_pointer(skb);
+	le64_to_cpus(&desc_hdr);
 
 	/* Check these packets */
 	desc_offset = (desc_hdr & AQ_RX_DH_DESC_OFFSET_MASK) >>
@@ -1110,14 +1433,14 @@ static int aqc111_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 		goto err;
 
 	/* Get the first RX packet descriptor */
-	pkt_desc_ptr = (u64 *)(skb->data + desc_offset);
+	pkt_desc = (u64 *)(skb->data + desc_offset);
 
 	while (pkt_count--) {
-		u64 pkt_desc = le64_to_cpup(pkt_desc_ptr);
-		u32 pkt_len_with_padd = 0;
 		u32 pkt_len = 0;
+		u32 pkt_len_with_padd = 0;
 
-		pkt_len = (u32)((pkt_desc & AQ_RX_PD_LEN_MASK) >>
+		le64_to_cpus(pkt_desc);
+		pkt_len = (u32)((*pkt_desc & AQ_RX_PD_LEN_MASK) >>
 			  AQ_RX_PD_LEN_SHIFT);
 		pkt_len_with_padd = ((pkt_len + 7) & 0x7FFF8);
 
@@ -1127,31 +1450,25 @@ static int aqc111_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 			goto err;
 		}
 
-		if (pkt_desc & AQ_RX_PD_DROP ||
-		    !(pkt_desc & AQ_RX_PD_RX_OK) ||
-		    pkt_len > (dev->hard_mtu + AQ_RX_HW_PAD)) {
-			skb_pull(skb, pkt_len_with_padd);
-			/* Next RX Packet Descriptor */
-			pkt_desc_ptr++;
-			continue;
-		}
+		if (*pkt_desc & AQ_RX_PD_DROP ||
+		    !(*pkt_desc & AQ_RX_PD_RX_OK) ||
+		    pkt_len > (dev->hard_mtu + AQ_RX_HW_PAD))
+			goto next_desc;
 
-		/* Clone SKB */
-		new_skb = skb_clone(skb, GFP_ATOMIC);
+		new_skb = netdev_alloc_skb_ip_align(dev->net, pkt_len);
 
 		if (!new_skb)
 			goto err;
 
-		new_skb->len = pkt_len;
+		skb_put_data(new_skb, skb->data, pkt_len);
 		skb_pull(new_skb, AQ_RX_HW_PAD);
-		skb_set_tail_pointer(new_skb, new_skb->len);
 
 		new_skb->truesize = SKB_TRUESIZE(new_skb->len);
 		if (aqc111_data->rx_checksum)
 			aqc111_rx_checksum(new_skb, pkt_desc);
 
-		if (pkt_desc & AQ_RX_PD_VLAN) {
-			vlan_tag = pkt_desc >> AQ_RX_PD_VLAN_SHIFT;
+		if (*pkt_desc & AQ_RX_PD_VLAN) {
+			vlan_tag = *pkt_desc >> AQ_RX_PD_VLAN_SHIFT;
 			__vlan_hwaccel_put_tag(new_skb, htons(ETH_P_8021Q),
 					       vlan_tag & VLAN_VID_MASK);
 		}
@@ -1160,10 +1477,11 @@ static int aqc111_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 		if (pkt_count == 0)
 			break;
 
+next_desc:
 		skb_pull(skb, pkt_len_with_padd);
 
-		/* Next RX Packet Header */
-		pkt_desc_ptr++;
+		/* Next RX Packet Descriptor */
+		pkt_desc++;
 
 		new_skb = NULL;
 	}
@@ -1179,7 +1497,6 @@ static struct sk_buff *aqc111_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
 {
 	int frame_size = dev->maxpacket;
 	struct sk_buff *new_skb = NULL;
-	u64 *tx_desc_ptr = NULL;
 	int padding_size = 0;
 	int headroom = 0;
 	int tailroom = 0;
@@ -1209,7 +1526,11 @@ static struct sk_buff *aqc111_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
 			   AQ_TX_DESC_VLAN_SHIFT;
 	}
 
-	if (!dev->can_dma_sg && (dev->net->features & NETIF_F_SG) &&
+	if (
+#if KERNEL_VERSION(3, 12, 0) <= LINUX_VERSION_CODE || (RHEL_RELEASE_CODE)
+	    !dev->can_dma_sg &&
+#endif
+	    (dev->net->features & NETIF_F_SG) &&
 	    skb_linearize(skb))
 		return NULL;
 
@@ -1225,10 +1546,11 @@ static struct sk_buff *aqc111_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
 			return NULL;
 	}
 	if (padding_size != 0)
-		skb_put_zero(skb, padding_size);
+		skb_put(skb, padding_size);
 	/* Copy TX header */
-	tx_desc_ptr = skb_push(skb, sizeof(tx_desc));
-	*tx_desc_ptr = cpu_to_le64(tx_desc);
+	skb_push(skb, sizeof(tx_desc));
+	cpu_to_le64s(&tx_desc);
+	skb_copy_to_linear_data(skb, &tx_desc, sizeof(tx_desc));
 
 	usbnet_set_skb_tx_stats(skb, 1, 0);
 
@@ -1351,13 +1673,19 @@ static int aqc111_suspend(struct usb_interface *intf, pm_message_t message)
 			      1, 1, &reg8);
 
 	if (aqc111_data->wol_flags) {
-		struct aqc111_wol_cfg wol_cfg;
-
-		memset(&wol_cfg, 0, sizeof(struct aqc111_wol_cfg));
+		struct aqc111_wol_cfg wol_cfg = { 0 };
 
 		aqc111_data->phy_cfg |= AQ_WOL;
-		ether_addr_copy(wol_cfg.hw_addr, dev->net->dev_addr);
-		wol_cfg.flags = aqc111_data->wol_flags;
+		if (aqc111_data->dpa) {
+			reg8 = 0;
+			if (aqc111_data->wol_flags & AQ_WOL_FLAG_MP)
+				reg8 |= SFR_MONITOR_MODE_RWMP;
+			aqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC,
+					      SFR_MONITOR_MODE, 1, 1, &reg8);
+		} else {
+			ether_addr_copy(wol_cfg.hw_addr, dev->net->dev_addr);
+			wol_cfg.flags = aqc111_data->wol_flags;
+		}
 
 		temp_rx_ctrl |= (SFR_RX_CTL_AB | SFR_RX_CTL_START);
 		aqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_CTL,
@@ -1391,14 +1719,24 @@ static int aqc111_suspend(struct usb_interface *intf, pm_message_t message)
 		aqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC,
 					SFR_MEDIUM_STATUS_MODE, 2, &reg16);
 
-		aqc111_write_cmd(dev, AQ_WOL_CFG, 0, 0,
-				 WOL_CFG_SIZE, &wol_cfg);
-		aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,
-				   &aqc111_data->phy_cfg);
+		if (aqc111_data->dpa) {
+			aqc111_set_phy_speed(dev, AUTONEG_ENABLE, SPEED_100);
+		} else {
+			aqc111_write_cmd(dev, AQ_WOL_CFG, 0, 0,
+					 WOL_CFG_SIZE, &wol_cfg);
+			aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,
+					   &aqc111_data->phy_cfg);
+		}
 	} else {
 		aqc111_data->phy_cfg |= AQ_LOW_POWER;
-		aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,
-				   &aqc111_data->phy_cfg);
+		if (!aqc111_data->dpa) {
+			aqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,
+					   &aqc111_data->phy_cfg);
+		} else {
+			reg16 = AQ_PHY_LOW_POWER_MODE;
+			aqc111_mdio_write(dev, AQ_GLB_STD_CTRL_REG,
+					  AQ_PHY_GLOBAL_ADDR, &reg16);
+		}
 
 		/* Disable RX path */
 		aqc111_read16_cmd_nopm(dev, AQ_ACCESS_MAC,
@@ -1424,6 +1762,23 @@ static int aqc111_resume(struct usb_interface *intf)
 	aqc111_data->phy_cfg |= AQ_PHY_POWER_EN;
 	aqc111_data->phy_cfg &= ~AQ_LOW_POWER;
 	aqc111_data->phy_cfg &= ~AQ_WOL;
+	if (aqc111_data->dpa) {
+		aqc111_read_cmd_nopm(dev, AQ_PHY_POWER, 0, 0, 1, &reg8);
+		if (reg8 == 0x00) {
+			reg8 = 0x02;
+			aqc111_write_cmd_nopm(dev, AQ_PHY_POWER, 0, 0,
+					      1, &reg8);
+			msleep(200);
+		}
+
+		aqc111_mdio_read(dev, AQ_GLB_STD_CTRL_REG, AQ_PHY_GLOBAL_ADDR,
+				 &reg16);
+		if (reg16 & AQ_PHY_LOW_POWER_MODE) {
+			reg16 &= ~AQ_PHY_LOW_POWER_MODE;
+			aqc111_mdio_write(dev, AQ_GLB_STD_CTRL_REG,
+					  AQ_PHY_GLOBAL_ADDR, &reg16);
+		}
+	}
 
 	reg8 = 0xFF;
 	aqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_BM_INT_MASK,
diff --git a/drivers/net/usb/aqc111.h b/drivers/net/usb/aqc111.h
index b562db4da..78c92183e 100644
--- a/drivers/net/usb/aqc111.h
+++ b/drivers/net/usb/aqc111.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/* Aquantia Corp. Aquantia AQtion USB to 5GbE Controller
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Aquantia Corp. Aquantia AQtion USB to 5GbE Controller
  * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>
  * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>
  * Copyright (C) 2002-2003 TiVo Inc.
@@ -18,12 +18,70 @@
 #define AQ_ACCESS_MAC			0x01
 #define AQ_FLASH_PARAMETERS		0x20
 #define AQ_PHY_POWER			0x31
+#define AQ_PHY_CMD			0x32
 #define AQ_WOL_CFG			0x60
 #define AQ_PHY_OPS			0x61
+#define AQ_PHY_THERMAL			0x64
+#define AQ_USBDC_CMD			0x81
+#define AQ_SWITCH_CONFIG		0xB0
+
+#define AQC111_PHY_ID			0x00
+#define AQ_PHY_ADDR(mmd)		((AQC111_PHY_ID << 8) | mmd)
+
+#define AQ_PHY_AUTONEG_MMD		0x07
+#define AQ_PHY_AUTONEG_ADDR		AQ_PHY_ADDR(AQ_PHY_AUTONEG_MMD)
+
+#define AQ_AUTONEG_STD_CTRL_REG		0x0000
+	#define AQ_ANEG_EX_PAGE_CTRL		0x2000
+	#define AQ_ANEG_EN_ANEG			0x1000
+	#define AQ_ANEG_RESTART_ANEG		0x0200
+
+#define AQ_AUTONEG_ADV_REG		0x0010
+	#define AQ_ANEG_100M			0x0100
+	#define AQ_ANEG_PAUSE			0x0400
+	#define AQ_ANEG_ASYM_PAUSE		0x0800
+	#define AQ_ANEG_ABILITY_MASK		0x0FE0
+
+#define AQ_AUTONEG_10GT_CTRL_REG	0x0020
+	#define AQ_ANEG_ADV_10G_T		0x1000
+	#define AQ_ANEG_ADV_5G_T		0x0100
+	#define AQ_ANEG_ADV_2G5_T		0x0080
+	#define AQ_ANEG_ADV_LT			0x0001
+
+#define AQ_AUTONEG_VEN_PROV1_REG	0xC400
+	#define AQ_ANEG_ADV_1G			0x8000
+	#define AQ_ANEG_ADV_AQRATE		0x1000
+	#define AQ_ANEG_ADV_5G_N		0x0800
+	#define AQ_ANEG_ADV_2G5_N		0x0400
+	#define AQ_ANEG_EX_PHY_ID		0x0040
+	#define AQ_ANEG_EN_DSH			0x0010
+	#define AQ_ANEG_DSH_RETRY		0x0003
+
+#define AQ_PHY_GLOBAL_MMD		0x1E
+#define AQ_PHY_GLOBAL_ADDR		AQ_PHY_ADDR(AQ_PHY_GLOBAL_MMD)
+
+#define AQ_GLB_STD_CTRL_REG		0x0000
+	#define AQ_PHY_LOW_POWER_MODE		0x0800
+
+#define AQ_GLB_SYS_CFG_REG_5G		0x031E
+	#define AQ_SERDES_MODE_MASK		0x0007
+	#define AQ_SERDES_MODE_XFI_DIV_2	0x0006
+	#define AQ_SERDES_MODE_XFI		0x0000
+
+#define AQ_GLB_ING_PAUSE_CTRL_REG	0x7148
+#define AQ_GLB_EGR_PAUSE_CTRL_REG	0x4148
 
 #define AQ_USB_PHY_SET_TIMEOUT		10000
 #define AQ_USB_SET_TIMEOUT		4000
 
+#define AQ_THERMAL_TIMER_MS		500
+/* Temperature thresholds in units degree of Celsius */
+#define AQ_NORMAL_TEMP_THRESHOLD	85
+#define AQ_HIGH_TEMP_THRESHOLD		106
+#define AQ_CRITICAL_TEMP_THRESHOLD	108
+
+#define AQ_SW_CONFIG_MAGIC_KEY		0xABBA
+#define AQ_SW_CONFIG_LAN		0x0001
 /* Feature. ********************************************/
 #define AQ_SUPPORT_FEATURE	(NETIF_F_SG | NETIF_F_IP_CSUM |\
 				 NETIF_F_IPV6_CSUM | NETIF_F_RXCSUM |\
@@ -38,6 +96,9 @@
 				 NETIF_F_IPV6_CSUM | NETIF_F_RXCSUM |\
 				 NETIF_F_TSO)
 
+/* DC Reg. *********************************************/
+#define DC_SS_CTL			0x310
+
 /* SFR Reg. ********************************************/
 
 #define SFR_GENERAL_STATUS		0x03
@@ -128,6 +189,10 @@
 #define AQ_FW_VER_MINOR			0xDB
 #define AQ_FW_VER_REV			0xDC
 
+#define AQ_PRIV_FLAGS_MASK		0x3
+#define AQ_PF_XFI_DIV_2			BIT(0)
+#define AQ_PF_THERMAL			BIT(1)
+
 /*PHY_OPS**********************************************************************/
 
 #define AQ_ADV_100M	BIT(0)
@@ -142,6 +207,7 @@
 #define AQ_PHY_POWER_EN	BIT(19)
 #define AQ_WOL		BIT(20)
 #define AQ_DOWNSHIFT	BIT(21)
+#define AQ_XFI_DIV_2	BIT(22)
 
 #define AQ_DSH_RETRIES_SHIFT	0x18
 #define AQ_DSH_RETRIES_MASK	0xF000000
@@ -156,6 +222,14 @@ struct aqc111_wol_cfg {
 	u8 rsvd[283];
 } __packed;
 
+struct aqc111_thermal_params {
+	u8 enable;
+	u8 threshold_critical;
+	u8 threshold_high;
+	u8 threshold_normal;
+	u8 phy_speed_mask;
+} __packed;
+
 #define WOL_CFG_SIZE sizeof(struct aqc111_wol_cfg)
 
 struct aqc111_data {
@@ -170,8 +244,10 @@ struct aqc111_data {
 		u8 minor;
 		u8 rev;
 	} fw_ver;
+	u8 dpa; /*direct PHY access*/
 	u32 phy_cfg;
 	u8 wol_flags;
+	u32 priv_flags;
 };
 
 #define AQ_LS_MASK		0x8000
-- 
Created with Armbian build tools https://github.com/armbian/build

